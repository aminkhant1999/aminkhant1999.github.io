<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Snake ‚Äî HTML5 Canvas</title>
<style>
  :root { --bg:#0b1220; --panel:#0f172a; --grid:#0e1a2b; --snake:#22c55e; --head:#16a34a; --food:#f97316; --text:#e5e7eb; --muted:#93a3b8; --accent:#38bdf8; }
  * { box-sizing: border-box; }
  body {
    margin: 0; min-height: 100vh; display: grid; place-items: center;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, sans-serif;
    background: radial-gradient(1200px 700px at 70% -10%, #162036, var(--bg));
    color: var(--text);
  }
  .wrap {
    width: min(680px, 94vw);
    background: linear-gradient(180deg, var(--panel), #0a1324);
    border: 1px solid #1a2336; border-radius: 16px; padding: 16px;
    box-shadow: 0 10px 30px rgba(0,0,0,.35);
  }
  header {
    display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;
    margin-bottom: 10px;
  }
  h1 { font-size: clamp(20px, 3.5vw, 28px); margin: 0; letter-spacing:.3px; }
  .stats { display:flex; gap:12px; flex-wrap:wrap; }
  .badge {
    background:#0d192d; border:1px solid #1e2a41; padding:8px 10px; border-radius:10px;
    font-weight:700; font-size:14px;
  }
  .badge small { display:block; color:var(--muted); font-weight:500; font-size:11px; }
  .board {
    background: var(--grid); border:1px solid #1e2a41; border-radius:12px; padding:10px;
    /* Important: prevent page scroll on swipe */
    touch-action: none;
  }
  /* Make the canvas responsive & square. Height will be set by JS; width is fluid. */
  canvas { display:block; width:100%; height:auto; border-radius:8px; background:#0b1324; }
  .panel {
    display:flex; justify-content:space-between; align-items:center; gap:10px; margin-top:10px; flex-wrap:wrap;
  }
  .controls { display:flex; gap:8px; flex-wrap:wrap; }
  button {
    background:#122036; color:var(--text); border:1px solid #263650;
    padding:10px 12px; border-radius:10px; cursor:pointer; transition: background .2s, transform .08s, border-color .2s;
    font-size:14px;
  }
  button:hover { background:#162745; border-color:#38557b; }
  button:active { transform: translateY(1px); }
  .hint { color:var(--muted); font-size:12px; text-align:center; margin-top:8px; }
  /* On-screen D-pad for touch */
  .dpad {
    display: grid; grid-template-areas: ". up ." "left . right" ". down .";
    gap: 6px; margin-left:auto;
  }
  .dpad button { width:46px; height:46px; padding:0; }
  .dpad .up { grid-area: up; }
  .dpad .down { grid-area: down; }
  .dpad .left { grid-area: left; }
  .dpad .right { grid-area: right; }
  @media (max-width: 420px) {
    .dpad button { width:42px; height:42px; }
  }
</style>
</head>
<body>
  <div class="wrap" aria-live="polite">
    <header>
      <h1>üêç Snake</h1>
      <div class="stats">
        <div class="badge"><small>Score</small><span id="score">0</span></div>
        <div class="badge"><small>High</small><span id="high">0</span></div>
        <div class="badge"><small>Speed</small>
          <select id="speed" aria-label="Speed">
            <option value="8">Slow</option>
            <option value="12" selected>Normal</option>
            <option value="16">Fast</option>
            <option value="22">Insane</option>
          </select>
        </div>
      </div>
    </header>

    <div class="board" id="board">
      <!-- Canvas size is responsive; JS manages internal resolution for crispness -->
      <canvas id="canvas" width="400" height="400" aria-label="Snake game area"></canvas>
    </div>

    <div class="panel">
      <div class="controls">
        <button id="btn-start">Start</button>
        <button id="btn-pause">Pause</button>
        <button id="btn-restart">Restart</button>
      </div>
      <div class="dpad" aria-label="Touch controls">
        <button class="up" data-dir="up" aria-label="Up">‚¨ÜÔ∏è</button>
        <button class="left" data-dir="left" aria-label="Left">‚¨ÖÔ∏è</button>
        <button class="right" data-dir="right" aria-label="Right">‚û°Ô∏è</button>
        <button class="down" data-dir="down" aria-label="Down">‚¨áÔ∏è</button>
      </div>
    </div>

    <div class="hint">Controls: Arrow keys / WASD ‚Ä¢ Pause: Space ‚Ä¢ Restart: R ‚Ä¢ Swipe to move on touch screens</div>
  </div>

<script>
(() => {
  // ----- Config -----
  const GRID = 20;              // logical grid (20x20)
  let TILE = 20;                // pixels per cell (computed responsively)
  let CANVAS_CSS = GRID * TILE; // CSS pixels (square side, computed)

  const SNAKE_COLOR = getCSS('--snake') || '#22c55e';
  const HEAD_COLOR  = getCSS('--head')  || '#16a34a';
  const FOOD_COLOR  = getCSS('--food')  || '#f97316';

  // ----- DOM -----
  const board   = document.getElementById('board');
  const canvas  = document.getElementById('canvas');
  const ctx     = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const highEl  = document.getElementById('high');
  const speedEl = document.getElementById('speed');
  const btnStart= document.getElementById('btn-start');
  const btnPause= document.getElementById('btn-pause');
  const btnRestart=document.getElementById('btn-restart');

  // ----- Responsive Canvas / HiDPI -----
  function resizeCanvas() {
    // Use the inner width of the board (content box) so canvas fills it.
    const cssSide = Math.floor(board.clientWidth - 20); // subtract a tiny safety margin
    CANVAS_CSS = cssSide > 140 ? cssSide : 140;         // clamp to a minimum size
    // Keep the canvas square visually
    canvas.style.width = CANVAS_CSS + 'px';
    canvas.style.height = CANVAS_CSS + 'px';

    // Device pixel ratio scaling for crisp rendering
    const dpr = window.devicePixelRatio || 1;
    canvas.width  = Math.floor(CANVAS_CSS * dpr);
    canvas.height = Math.floor(CANVAS_CSS * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // Compute TILE from CSS size (integer for crisp grid lines)
    TILE = Math.floor(CANVAS_CSS / GRID);
  }
  resizeCanvas();
  window.addEventListener('resize', () => { resizeCanvas(); draw(); });

  // ----- Game State -----
  let snake, dir, queuedDir, food, score, high, running, lastTime, acc, step, gameOver, hasStarted;

  function setSpeed(spd) { step = 1000 / spd; }

  // Initialize / Reset state
  function reset() {
    snake = [{x:10, y:10},{x:9,y:10},{x:8,y:10}]; // start mid
    dir = {x:1, y:0}; queuedDir = {x:1, y:0};
    food = spawnFood();
    score = 0; gameOver = false; hasStarted = false;
    acc = 0; lastTime = performance.now();
    setSpeed(parseInt(speedEl.value, 10));
    scoreEl.textContent = score;
    high = parseInt(localStorage.getItem('snake_high') || '0', 10);
    highEl.textContent = high;
    draw(); // immediate draw
    drawBanner('Press Arrow/WASD or Swipe to start');
  }

  function spawnFood() {
    let pos;
    do {
      pos = { x: randInt(0, GRID-1), y: randInt(0, GRID-1) };
    } while (snake.some(s => s.x === pos.x && s.y === pos.y));
    return pos;
  }

  function randInt(min, max) { // inclusive
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // ----- Input Helpers -----
  function isReverse(nx, ny) {
    return (nx === -dir.x && ny === -dir.y);
  }
  function queueDir(nx, ny) {
    if (isReverse(nx, ny)) return;
    queuedDir = {x:nx, y:ny};
  }

  function startIfNeeded() {
    if (!running && !gameOver) {
      hasStarted = true;
      start();
    }
  }

  // Keyboard input
  window.addEventListener('keydown', e => {
    const k = e.key.toLowerCase();
    if (k === 'arrowup' || k === 'w') { queueDir(0,-1); startIfNeeded(); }
    else if (k === 'arrowdown' || k === 's') { queueDir(0,1); startIfNeeded(); }
    else if (k === 'arrowleft' || k === 'a') { queueDir(-1,0); startIfNeeded(); }
    else if (k === 'arrowright' || k === 'd') { queueDir(1,0); startIfNeeded(); }
    else if (k === ' ') { togglePause(); }
    else if (k === 'r') { hardRestart(); }
  });

  // Touch swipe input
  let touchStartX = 0, touchStartY = 0, touchActive = false;
  const SWIPE_THRESH = 24; // pixels

  board.addEventListener('touchstart', e => {
    if (!e.touches || e.touches.length === 0) return;
    const t = e.touches[0];
    touchStartX = t.clientX; touchStartY = t.clientY;
    touchActive = true;
  }, { passive: true });

  board.addEventListener('touchmove', e => {
    // Prevent page scroll while swiping on the game board
    if (touchActive) e.preventDefault();
  }, { passive: false });

  board.addEventListener('touchend', e => {
    if (!touchActive) return;
    touchActive = false;
    const t = (e.changedTouches && e.changedTouches[0]) || null;
    if (!t) return;
    const dx = t.clientX - touchStartX;
    const dy = t.clientY - touchStartY;
    if (Math.max(Math.abs(dx), Math.abs(dy)) < SWIPE_THRESH) return;

    if (Math.abs(dx) > Math.abs(dy)) {
      // horizontal
      if (dx > 0) queueDir(1,0); else queueDir(-1,0);
    } else {
      // vertical
      if (dy > 0) queueDir(0,1); else queueDir(0,-1);
    }
    startIfNeeded();
  }, { passive: true });

  // D-pad (click/tap)
  document.querySelectorAll('.dpad button').forEach(btn => {
    btn.addEventListener('click', () => {
      const d = btn.dataset.dir;
      if (d==='up') queueDir(0,-1);
      if (d==='down') queueDir(0,1);
      if (d==='left') queueDir(-1,0);
      if (d==='right') queueDir(1,0);
      startIfNeeded();
    });
  });

  // Buttons & speed
  btnStart.addEventListener('click', () => { startIfNeeded(); });
  btnPause.addEventListener('click', togglePause);
  btnRestart.addEventListener('click', hardRestart);
  speedEl.addEventListener('change', () => setSpeed(parseInt(speedEl.value,10)));

  // ----- Loop -----
  function start() {
    if (running && !gameOver) return;
    running = true; gameOver = false;
    lastTime = performance.now(); acc = 0;
    requestAnimationFrame(loop);
  }
  function togglePause() {
    if (gameOver) return;
    running = !running;
    if (running) {
      lastTime = performance.now(); acc = 0;
      requestAnimationFrame(loop);
    } else {
      drawBanner('Paused ‚Äî press Space to resume');
    }
  }
  function hardRestart() { reset(); start(); }

  function loop(t) {
    if (!running) return;
    const dt = t - lastTime;
    lastTime = t;
    acc += dt;

    // Progress in fixed steps (grid movement)
    while (acc >= step) {
      update();
      acc -= step;
      if (gameOver) { running = false; break; }
    }
    draw();
    if (running) requestAnimationFrame(loop);
  }

  // ----- Update -----
  function update() {
    // apply queued direction at step boundary
    dir = queuedDir;

    // next head position
    const head = snake[0];
    const nx = head.x + dir.x;
    const ny = head.y + dir.y;

    // wall collision
    if (nx < 0 || ny < 0 || nx >= GRID || ny >= GRID) { return endGame(); }
    // self collision
    if (snake.some((s,i) => i>0 && s.x===nx && s.y===ny)) { return endGame(); }

    // move: add new head
    snake.unshift({x:nx, y:ny});

    // food?
    if (nx === food.x && ny === food.y) {
      score += 1;
      scoreEl.textContent = score;
      if (score > high) { high = score; highEl.textContent = high; localStorage.setItem('snake_high', String(high)); }
      food = spawnFood();
    } else {
      // trim tail (no growth)
      snake.pop();
    }
  }

  function endGame() {
    gameOver = true;
    draw(); // final frame
    drawBanner('üíÄ Game Over ‚Äî press R to restart');
  }

  // ----- Render -----
  function draw() {
    // Canvas CSS side derived; draw in CSS pixel coordinates (transform already accounts for DPR)
    const side = TILE * GRID;

    // clear
    ctx.fillStyle = '#081021';
    ctx.fillRect(0, 0, side, side);

    // draw grid (subtle)
    ctx.strokeStyle = 'rgba(255,255,255,0.045)';
    ctx.lineWidth = 1;
    for (let i=1; i<GRID; i++){
      const p = i*TILE;
      ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,side); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(side,p); ctx.stroke();
    }

    // food
    drawCell(food.x, food.y, FOOD_COLOR, Math.max(4, Math.floor(TILE*0.3)));

    // snake
    snake.forEach((seg, idx) => {
      const color = idx === 0 ? HEAD_COLOR : SNAKE_COLOR;
      drawCell(seg.x, seg.y, color, idx === 0 ? Math.max(3, Math.floor(TILE*0.2)) : Math.max(4, Math.floor(TILE*0.22)));
    });
  }

  function drawCell(x, y, color, inset=4) {
    const px = x*TILE, py = y*TILE;
    const w = TILE - 2*inset, h = TILE - 2*inset;
    ctx.fillStyle = color;
    const r = Math.max(2, Math.floor(TILE*0.25)); // rounded corners scale with TILE
    roundRect(ctx, px+inset, py+inset, w, h, r);
    ctx.fill();
  }

  function roundRect(ctx, x, y, w, h, r=6) {
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  function drawBanner(text) {
    const side = TILE * GRID;
    // overlay banner
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    const barH = Math.max(48, Math.floor(side * 0.16));
    ctx.fillRect(0, (side - barH)/2, side, barH);
    ctx.fillStyle = '#e5e7eb';
    ctx.font = `${Math.max(14, Math.floor(side*0.04))}px system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, side/2, side/2);
    ctx.restore();
  }

  function getCSS(varName) {
    return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
  }

  // Boot
  reset();
})();
</script>
</body>
</html>
